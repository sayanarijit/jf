USAGE

  jf TEMPLATE [VALUE]... [NAME=VALUE]... [NAME@FILE]...

  Where TEMPLATE may contain the following placeholders:

  `%q`  quoted and safely escaped JSON string
  `%s`  JSON values other than string
  `%v`  the `jf` version number
  `%%`  a literal `%` character

  And [VALUE]... [NAME=VALUE]... [NAME@FILE]... are the values for the placeholders.

SYNTAX

  `%s`                `%q`                read positional argument
  `%-s`               `%-q`               read stdin
  `%(NAME)s`          `%(NAME)q`          read named value from argument
  `%(NAME=DEFAULT)s`  `%(NAME=DEFAULT)q`  placeholder with default value
  `%(NAME@FILE)s`     `%(NAME@FILE)q`     read default value from file path
  `%(NAME@-)s`        `%(NAME@-)q`        read default value from stdin
  `%(NAME?)s`         `%(NAME?)q`         nullable placeholder that defaults to null
  `%(NAME)?s`         `%(NAME)?q`         optional placeholder that defaults to blank
  `%*s`               `%*q`               expand positional args as array items
  `%*-s`              `%*-q`              expand stdin as array items
  `%**s`              `%**q`              expand positional args as key value pairs
  `%**-s`             `%**-q`             expand stdin as key value pairs
  `%(NAME)*s`         `%(NAME)*q`         expand named args as array items
  `%(NAME)**s`        `%(NAME)**q`        expand named args as key value pairs

RULES

  * Pass values for positional placeholders in the same order as in the template.
  * Pass values to stdin following the order and separate them with null byte (`\0`).
  * Pass values for named placeholders using `NAME=VALUE` syntax.
  * Pass values for named array items using `NAME=ITEM_N` syntax.
  * Pass values for named key value pairs using `NAME=KEY_N NAME=VALUE_N` syntax.
  * Use `NAME@FILE` syntax to read from file where FILE can be `-` for stdin.
  * Do not declare or pass positional placeholders or values after named ones.
  * To allow merging arrays and objects via expansion, trailing comma after `s` and `q`
    will be auto removed after the expansion if no value is passed for the placeholder.

EXAMPLES

  - Run: jf %s 1
  - Out: 1

  - Run: jf %q 1
  - Out: "1"

  - Run: jf '{%**q}' one 1 two 2 three 3
  - Out: {"one":"1","two":"2","three":"3"}

  - Run: seq 1 3 | xargs printf '%s\0' | jf '[%*-s]'
  - Out: [1,2,3]

  - Run: jf "{%q: %(value=default)q, %(bar)**q}" foo value=bar bar=biz bar=baz
  - Out: {"foo":"bar","biz":"baz"}

  - Run: jf "{str or bool: %(str)?q %(bool)?s, nullable: %(nullable?)q}" str=true
  - Out: {"str or bool":"true","nullable":null}

  - Run: jf '{1: %s, two: %q, 3: %(3)s, four: %(four=4)q, "%%": %(pct?)q}' 1 2 3=3
  - Out: {"1":1,"two":"2","3":3,"four":"4","%":null}

SHELL ALIASES

  You can set the following aliases in your shell:

  - alias str='jf %q'
  - alias arr='jf "[%*s]"'
  - alias obj='jf "{%**s}"'

  Then you can use them like this:

  - Run: str 1
  - Out: "1"

  - Run: arr 1 2 3
  - Out: [1,2,3]

  - Run: obj one 1 two 2 three 3
  - Out: {"one":1,"two":2,"three":3}

  - Run: obj 1 2 3 $(arr 4 $(str 5))
  - Out: {"1":2,"3":[4,"5"]}
